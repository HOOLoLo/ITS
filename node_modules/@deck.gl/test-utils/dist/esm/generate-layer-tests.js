import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _typeof from "@babel/runtime/helpers/esm/typeof";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { _count as count } from '@deck.gl/core';

function noop() {}

function defaultAssert(condition, comment) {
  if (!condition) {
    throw new Error(comment);
  }
}

export function generateLayerTests(_ref) {
  var Layer = _ref.Layer,
      _ref$sampleProps = _ref.sampleProps,
      sampleProps = _ref$sampleProps === void 0 ? {} : _ref$sampleProps,
      _ref$assert = _ref.assert,
      assert = _ref$assert === void 0 ? defaultAssert : _ref$assert,
      _ref$onBeforeUpdate = _ref.onBeforeUpdate,
      onBeforeUpdate = _ref$onBeforeUpdate === void 0 ? noop : _ref$onBeforeUpdate,
      _ref$onAfterUpdate = _ref.onAfterUpdate,
      onAfterUpdate = _ref$onAfterUpdate === void 0 ? noop : _ref$onAfterUpdate,
      _ref$runDefaultAssert = _ref.runDefaultAsserts,
      runDefaultAsserts = _ref$runDefaultAssert === void 0 ? true : _ref$runDefaultAssert;
  assert(Layer.layerName, 'Layer should have display name');

  function wrapTestCaseTitle(title) {
    return "".concat(Layer.layerName, "#").concat(title);
  }

  var testCases = [{
    title: 'Empty props',
    props: {}
  }, {
    title: 'Null data',
    updateProps: {
      data: null
    }
  }, {
    title: 'Sample data',
    updateProps: sampleProps
  }];

  try {
    new Layer({});
  } catch (error) {
    assert(false, "Construct ".concat(Layer.layerName, " throws: ").concat(error.message));
  }

  var propTypes = Layer._propTypes,
      defaultProps = Layer._mergedDefaultProps;
  testCases.push.apply(testCases, _toConsumableArray(makeAltDataTestCases(sampleProps, propTypes)));

  for (var propName in Layer.defaultProps) {
    if (!(propName in sampleProps)) {
      var newTestCase = makeAltPropTestCase({
        propName: propName,
        propTypes: propTypes,
        defaultProps: defaultProps,
        sampleProps: sampleProps,
        assert: assert
      }) || [];
      testCases.push.apply(testCases, _toConsumableArray(newTestCase));
    }
  }

  testCases.forEach(function (testCase) {
    testCase.title = wrapTestCaseTitle(testCase.title);
    var beforeFunc = testCase.onBeforeUpdate || noop;
    var afterFunc = testCase.onAfterUpdate || noop;

    testCase.onBeforeUpdate = function (params) {
      beforeFunc(params);
      onBeforeUpdate(params);
    };

    testCase.onAfterUpdate = function (params) {
      afterFunc(params);
      onAfterUpdate(params);

      if (runDefaultAsserts) {
        if (params.layer.isComposite) {
          var data = params.layer.props.data;

          if (data && _typeof(data) === 'object' && count(data)) {
            assert(params.subLayers.length, 'Layer should have sublayers');
          }
        } else {
          assert(params.layer.getModels().length, 'Layer should have models');
        }
      }
    };
  });
  return testCases;
}

function makeAltPropTestCase(_ref2) {
  var propName = _ref2.propName,
      propTypes = _ref2.propTypes,
      defaultProps = _ref2.defaultProps,
      sampleProps = _ref2.sampleProps,
      assert = _ref2.assert;

  var newProps = _objectSpread({}, sampleProps);

  var propDef = propTypes[propName];

  if (!propDef) {
    return null;
  }

  switch (propDef.type) {
    case 'boolean':
      newProps[propName] = !defaultProps[propName];
      return [{
        title: "".concat(propName, ": ").concat(String(newProps[propName])),
        props: newProps
      }];

    case 'number':
      if ('max' in propDef) {
        newProps[propName] = propDef.max;
      } else if ('min' in propDef) {
        newProps[propName] = propDef.min;
      } else {
        newProps[propName] = defaultProps[propName] + 1;
      }

      return [{
        title: "".concat(propName, ": ").concat(String(newProps[propName])),
        props: newProps
      }];

    case 'accessor':
      {
        if (typeof defaultProps[propName] === 'function') {
          return null;
        }

        var callCount = 0;

        newProps[propName] = function () {
          callCount++;
          return defaultProps[propName];
        };

        newProps.updateTriggers = _defineProperty({}, propName, 'function');

        var onBeforeUpdate = function onBeforeUpdate() {
          return callCount = 0;
        };

        var onAfterUpdate = function onAfterUpdate() {
          return assert(callCount > 0, 'accessor function is called');
        };

        return [{
          title: "".concat(propName, ": () => ").concat(defaultProps[propName]),
          props: newProps,
          onBeforeUpdate: onBeforeUpdate,
          onAfterUpdate: onAfterUpdate
        }, {
          title: "".concat(propName, ": updateTrigger"),
          updateProps: {
            updateTriggers: _defineProperty({}, propName, 'function+trigger')
          },
          onBeforeUpdate: onBeforeUpdate,
          onAfterUpdate: onAfterUpdate
        }];
      }

    default:
      return null;
  }
}

function makeAltDataTestCases(props, propTypes) {
  var originalData = props.data;

  if (!Array.isArray(originalData)) {
    return [];
  }

  var partialUpdateProps = {
    data: originalData.slice(),
    _dataDiff: function _dataDiff() {
      return [{
        startRow: 0,
        endRow: 2
      }];
    }
  };
  var genIterableProps = {
    data: new Set(originalData),
    _dataDiff: null
  };
  var nonIterableProps = {
    data: {
      length: originalData.length
    }
  };

  var _loop = function _loop(propName) {
    if (propTypes[propName].type === 'accessor') {
      nonIterableProps[propName] = function (_, info) {
        return props[propName](originalData[info.index], info);
      };
    }
  };

  for (var propName in props) {
    _loop(propName);
  }

  return [{
    title: 'Partial update',
    updateProps: partialUpdateProps
  }, {
    title: 'Generic iterable data',
    updateProps: genIterableProps
  }, {
    title: 'non-iterable data',
    updateProps: nonIterableProps
  }];
}
//# sourceMappingURL=generate-layer-tests.js.map