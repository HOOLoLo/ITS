import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { _count as count } from '@deck.gl/core';

function noop() {}

function defaultAssert(condition, comment) {
  if (!condition) {
    throw new Error(comment);
  }
}

export function generateLayerTests({
  Layer,
  sampleProps = {},
  assert = defaultAssert,
  onBeforeUpdate = noop,
  onAfterUpdate = noop,
  runDefaultAsserts = true
}) {
  assert(Layer.layerName, 'Layer should have display name');

  function wrapTestCaseTitle(title) {
    return "".concat(Layer.layerName, "#").concat(title);
  }

  const testCases = [{
    title: 'Empty props',
    props: {}
  }, {
    title: 'Null data',
    updateProps: {
      data: null
    }
  }, {
    title: 'Sample data',
    updateProps: sampleProps
  }];

  try {
    new Layer({});
  } catch (error) {
    assert(false, "Construct ".concat(Layer.layerName, " throws: ").concat(error.message));
  }

  const {
    _propTypes: propTypes,
    _mergedDefaultProps: defaultProps
  } = Layer;
  testCases.push(...makeAltDataTestCases(sampleProps, propTypes));

  for (const propName in Layer.defaultProps) {
    if (!(propName in sampleProps)) {
      const newTestCase = makeAltPropTestCase({
        propName,
        propTypes,
        defaultProps,
        sampleProps,
        assert
      }) || [];
      testCases.push(...newTestCase);
    }
  }

  testCases.forEach(testCase => {
    testCase.title = wrapTestCaseTitle(testCase.title);
    const beforeFunc = testCase.onBeforeUpdate || noop;
    const afterFunc = testCase.onAfterUpdate || noop;

    testCase.onBeforeUpdate = params => {
      beforeFunc(params);
      onBeforeUpdate(params);
    };

    testCase.onAfterUpdate = params => {
      afterFunc(params);
      onAfterUpdate(params);

      if (runDefaultAsserts) {
        if (params.layer.isComposite) {
          const {
            data
          } = params.layer.props;

          if (data && typeof data === 'object' && count(data)) {
            assert(params.subLayers.length, 'Layer should have sublayers');
          }
        } else {
          assert(params.layer.getModels().length, 'Layer should have models');
        }
      }
    };
  });
  return testCases;
}

function makeAltPropTestCase({
  propName,
  propTypes,
  defaultProps,
  sampleProps,
  assert
}) {
  const newProps = _objectSpread({}, sampleProps);

  const propDef = propTypes[propName];

  if (!propDef) {
    return null;
  }

  switch (propDef.type) {
    case 'boolean':
      newProps[propName] = !defaultProps[propName];
      return [{
        title: "".concat(propName, ": ").concat(String(newProps[propName])),
        props: newProps
      }];

    case 'number':
      if ('max' in propDef) {
        newProps[propName] = propDef.max;
      } else if ('min' in propDef) {
        newProps[propName] = propDef.min;
      } else {
        newProps[propName] = defaultProps[propName] + 1;
      }

      return [{
        title: "".concat(propName, ": ").concat(String(newProps[propName])),
        props: newProps
      }];

    case 'accessor':
      {
        if (typeof defaultProps[propName] === 'function') {
          return null;
        }

        let callCount = 0;

        newProps[propName] = () => {
          callCount++;
          return defaultProps[propName];
        };

        newProps.updateTriggers = {
          [propName]: 'function'
        };

        const onBeforeUpdate = () => callCount = 0;

        const onAfterUpdate = () => assert(callCount > 0, 'accessor function is called');

        return [{
          title: "".concat(propName, ": () => ").concat(defaultProps[propName]),
          props: newProps,
          onBeforeUpdate,
          onAfterUpdate
        }, {
          title: "".concat(propName, ": updateTrigger"),
          updateProps: {
            updateTriggers: {
              [propName]: 'function+trigger'
            }
          },
          onBeforeUpdate,
          onAfterUpdate
        }];
      }

    default:
      return null;
  }
}

function makeAltDataTestCases(props, propTypes) {
  const originalData = props.data;

  if (!Array.isArray(originalData)) {
    return [];
  }

  const partialUpdateProps = {
    data: originalData.slice(),
    _dataDiff: () => [{
      startRow: 0,
      endRow: 2
    }]
  };
  const genIterableProps = {
    data: new Set(originalData),
    _dataDiff: null
  };
  const nonIterableProps = {
    data: {
      length: originalData.length
    }
  };

  for (const propName in props) {
    if (propTypes[propName].type === 'accessor') {
      nonIterableProps[propName] = (_, info) => props[propName](originalData[info.index], info);
    }
  }

  return [{
    title: 'Partial update',
    updateProps: partialUpdateProps
  }, {
    title: 'Generic iterable data',
    updateProps: genIterableProps
  }, {
    title: 'non-iterable data',
    updateProps: nonIterableProps
  }];
}
//# sourceMappingURL=generate-layer-tests.js.map