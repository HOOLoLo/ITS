import { LayerManager, MapView, DeckRenderer } from '@deck.gl/core';
import { makeSpy } from '@probe.gl/test-utils';
import gl from './utils/setup-gl';
const testViewport = new MapView().makeViewport({
  width: 100,
  height: 100,
  viewState: {
    longitude: 0,
    latitude: 0,
    zoom: 1
  }
});

function defaultOnError(error, title) {
  if (error) {
    throw error;
  }
}

export function testInitializeLayer({
  layer,
  viewport = testViewport,
  onError: _onError = defaultOnError
}) {
  const layerManager = new LayerManager(gl, {
    viewport
  });
  layerManager.setProps({
    onError: error => _onError(error, "initializing ".concat(layer.id))
  });
  layerManager.setLayers([layer]);
  layerManager.finalize();
  return null;
}
export function testLayer(opts) {
  const {
    Layer,
    testCases = [],
    spies = [],
    onError = defaultOnError
  } = opts;
  const resources = setupLayerTests("testing ".concat(Layer.layerName), opts);
  let layer = new Layer();

  for (const testCase of testCases) {
    const oldState = Object.assign({}, layer.state);
    const {
      layer: newLayer,
      spyMap
    } = runLayerTestUpdate(testCase, resources, layer, spies);
    runLayerTestPostUpdateCheck(testCase, newLayer, oldState, spyMap);
    Object.keys(spyMap).forEach(k => spyMap[k].reset());
    layer = newLayer;
  }

  const error = cleanupAfterLayerTests(resources);

  if (error) {
    onError(error, "".concat(Layer.layerName, " should delete all resources"));
  }
}
export async function testLayerAsync(opts) {
  const {
    Layer,
    testCases = [],
    spies = [],
    onError = defaultOnError
  } = opts;
  const resources = setupLayerTests("testing ".concat(Layer.layerName), opts);
  let layer = new Layer();

  for (const testCase of testCases) {
    const oldState = Object.assign({}, layer.state);
    const {
      layer: newLayer,
      spyMap
    } = runLayerTestUpdate(testCase, resources, layer, spies);
    runLayerTestPostUpdateCheck(testCase, newLayer, oldState, spyMap);

    while (!newLayer.isLoaded) {
      await update(resources);
      runLayerTestPostUpdateCheck(testCase, newLayer, oldState, spyMap);
    }

    Object.keys(spyMap).forEach(k => spyMap[k].reset());
    layer = newLayer;
  }

  const error = cleanupAfterLayerTests(resources);

  if (error) {
    onError(error, "".concat(Layer.layerName, " should delete all resources"));
  }
}

function setupLayerTests(testTitle, {
  viewport = testViewport,
  timeline = null,
  onError: _onError2 = defaultOnError
}) {
  const oldResourceCounts = getResourceCounts();
  const layerManager = new LayerManager(gl, {
    viewport,
    timeline
  });
  const deckRenderer = new DeckRenderer(gl);
  layerManager.context.animationProps = {
    time: 0
  };
  const props = {
    onError: error => _onError2(error, testTitle)
  };
  layerManager.setProps(props);
  deckRenderer.setProps(props);
  return {
    layerManager,
    deckRenderer,
    oldResourceCounts
  };
}

function cleanupAfterLayerTests({
  layerManager,
  deckRenderer,
  oldResourceCounts
}) {
  layerManager.setLayers([]);
  layerManager.finalize();
  deckRenderer.finalize();
  const resourceCounts = getResourceCounts();

  for (const resourceName in resourceCounts) {
    if (resourceCounts[resourceName] !== oldResourceCounts[resourceName]) {
      return new Error("".concat(resourceCounts[resourceName] - oldResourceCounts[resourceName], " ").concat(resourceName, "s"));
    }
  }

  return null;
}

function getResourceCounts() {
  const resourceStats = luma.stats.get('Resource Counts');
  return {
    Texture2D: resourceStats.get('Texture2Ds Active').count,
    Buffer: resourceStats.get('Buffers Active').count
  };
}

function injectSpies(layer, spies) {
  const spyMap = {};

  if (spies) {
    for (const functionName of spies) {
      spyMap[functionName] = makeSpy(Object.getPrototypeOf(layer), functionName);
    }
  }

  return spyMap;
}

function runLayerTestPostUpdateCheck(testCase, newLayer, oldState, spyMap) {
  if (testCase.onAfterUpdate) {
    const subLayers = newLayer.isComposite ? newLayer.getSubLayers() : [];
    const subLayer = subLayers.length && subLayers[0];
    testCase.onAfterUpdate({
      testCase,
      layer: newLayer,
      oldState,
      subLayers,
      subLayer,
      spies: spyMap
    });
  }
}

function runLayerTestUpdate(testCase, {
  layerManager,
  deckRenderer
}, layer, spies) {
  const {
    props,
    updateProps,
    onBeforeUpdate,
    viewport = layerManager.context.viewport
  } = testCase;

  if (onBeforeUpdate) {
    onBeforeUpdate({
      layer,
      testCase
    });
  }

  if (props) {
    layer = new layer.constructor(props);
  } else if (updateProps) {
    layer = layer.clone(updateProps);
  }

  spies = testCase.spies || spies;
  const spyMap = injectSpies(layer, spies);
  layerManager.setLayers([layer]);
  deckRenderer.renderLayers({
    viewports: [viewport],
    layers: layerManager.getLayers(),
    onViewportActive: layerManager.activateViewport
  });
  return {
    layer,
    spyMap
  };
}

function update({
  layerManager,
  deckRenderer
}) {
  return new Promise(resolve => {
    const onAnimationFrame = () => {
      if (layerManager.needsUpdate()) {
        layerManager.updateLayers();
        deckRenderer.renderLayers({
          viewports: [layerManager.context.viewport],
          layers: layerManager.getLayers(),
          onViewportActive: layerManager.activateViewport
        });
        resolve();
        return;
      }

      setTimeout(onAnimationFrame, 50);
    };

    onAnimationFrame();
  });
}
//# sourceMappingURL=lifecycle-test.js.map